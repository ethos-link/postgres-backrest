<!-- ────────────── Postgres + PgBackRest (production extract) ────────────── -->

# Postgres + PgBackRest

A production-friendly PostgreSQL image with PgBackRest preinstalled and a sane default configuration.

This image is maintained by **Ethos Link** (<https://ethos-link.com>). It’s a small, reusable extraction from real operations work we do for **Reviato** (<https://www.reviato.com>), a review intelligence product built by Ethos Link.

The goal is simple: make it easy for builders to run Postgres with backups and predictable configuration—without turning your repo into an ops research project.

---

## What you get

- **PostgreSQL + PgBackRest** in one image (based on the upstream `postgres` image)
- **WAL archiving-ready** defaults (pair this with a PgBackRest repo config)
- **Bring-your-own `postgresql.conf`** (pgtune-friendly) via a mounted file
- **Drop-in overrides** via `/etc/postgresql/conf.d/*.conf` (optional)

---

> [!WARNING]
> This is still in progress and this method of building the image has not yet been tested on production.
> This message will disappear when tested, PR's are welcome

## Quickstart

```bash
docker run \
 -e POSTGRES_PASSWORD=mysecretpassword \
 ghcr.io/your-org/postgres-backrest:latest
```

## Configuration

### PostgreSQL Configuration

The image ships with a default `/etc/postgresql/postgresql.conf`.

For anything beyond a couple of settings, the recommended practice is to provide a real Postgres config file (for example one generated by <https://pgtune.leopard.in.ua>) and mount it into the container.

**Option A (simplest): replace the default config**

1. Generate a config on pgtune.
2. Save it as `postgresql.conf`.
3. Mount it to `/etc/postgresql/postgresql.conf`.

Example (docker run):

```bash
docker run \
 -e POSTGRES_PASSWORD=mysecretpassword \
 -v "$PWD/postgresql.conf:/etc/postgresql/postgresql.conf:ro" \
 ghcr.io/your-org/postgres-backrest:latest
```

**Option B: mount the config elsewhere and point Postgres at it**

Set `POSTGRES_CONFIG_FILE` to the file you mounted:

```bash
docker run \
 -e POSTGRES_PASSWORD=mysecretpassword \
 -e POSTGRES_CONFIG_FILE=/etc/postgresql/pgtune/postgresql.conf \
 -v "$PWD/postgresql.conf:/etc/postgresql/pgtune/postgresql.conf:ro" \
 ghcr.io/your-org/postgres-backrest:latest
```

**Option C: mount small overrides (recommended when you only need a couple of changes)**

The shipped `postgresql.conf` includes `include_dir = 'conf.d'`, so you can mount a small snippet without replacing the full file:

```bash
docker run \
 -e POSTGRES_PASSWORD=mysecretpassword \
 -v "$PWD/overrides.conf:/etc/postgresql/conf.d/overrides.conf:ro" \
 ghcr.io/your-org/postgres-backrest:latest
```

**Notes**

- PostgreSQL does not offer a comprehensive, standardized set of environment variables for tuning knobs like `shared_buffers`, `work_mem`, `effective_cache_size`, etc. The established approach is managing `postgresql.conf` (and optionally `conf.d` snippets) as configuration artifacts.
- If you use container memory limits, treat pgtune output as a baseline and validate values against your runtime limits.

**Extra knobs supported by this image**

- `POSTGRES_CONFIG_FILE` (default: `/etc/postgresql/postgresql.conf`)
- `POSTGRES_HBA_FILE` (default: `/etc/postgresql/pg_hba.conf`)

These are used to inject `-c config_file=...` and `-c hba_file=...` when the container is started with the `postgres` command.

### PgBackRest Configuration

On startup, the container renders `/etc/pgbackrest/pgbackrest.conf` from the template at `/usr/local/share/pgbackrest/pgbackrest.conf.template` using `envsubst`.

The default template is intentionally minimal and local-by-default. To customize PgBackRest behavior (including S3/R2/backends, retention, compression, etc.), the established approach is to provide your own **template** by mounting it into the container at:

- `/usr/local/share/pgbackrest/pgbackrest.conf.template`

See the shipped template in this repo at `postgres-backrest/pgbackrest.conf.template`.

Common env vars referenced by the default template:

- `PGBACKREST_REPO1_PATH`
- `PGBACKREST_REPO1_RETENTION_FULL`
- `PGBACKREST_REPO1_RETENTION_DIFF`
- `PGBACKREST_PROCESS_MAX`
- `PGBACKREST_LOG_LEVEL_CONSOLE`
- `PGBACKREST_LOG_LEVEL_FILE`
- `PGBACKREST_LOG_PATH`
- `PGBACKREST_COMPRESS_TYPE`
- `PGBACKREST_COMPRESS_LEVEL`
- `PGBACKREST_PG1_PATH`

If you’re looking for a full “prod on a single server” setup (including S3-compatible repos, runbooks, and restore flows), see the Kamal-based reference in `infrastructure/`.

---

## Deploying with Kamal (reference)

This image is designed to work cleanly with Kamal accessory deployments.

- Start here: `infrastructure/README.md`
- You’ll typically mount:
  - a durable Postgres data volume
  - your `postgresql.conf` (or `conf.d` overrides)
  - any PgBackRest template/config required for your repo backend

## Building

To build the image with a specific PostgreSQL version:

```bash
docker build --build-arg POSTGRES_VERSION=18.1 -t postgres-backrest:18.1 .
```

## Publishing

The image is published to Docker Hub and GitHub Container Registry.

To update to a new PostgreSQL version, pass a different `POSTGRES_VERSION` build-arg (or change the Dockerfile default) and rebuild.

## License

MIT

